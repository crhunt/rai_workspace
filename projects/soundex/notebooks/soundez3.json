{
  "cells": [
    {
      "id": "b7638d7a-92ca-47c9-a400-278a4bfe05e8",
      "inputs": [
      ],
      "isCodeFolded": true,
      "name": "",
      "source": "# Soundex\n\n## What is Soundex?\n\nFrom Wikipedia:\n\n> Soundex is a phonetic algorithm for indexing names by sound, as pronounced in English. The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling.\n\n> The algorithm mainly encodes consonants; a vowel will not be encoded unless it is the first letter. Soundex is the most widely known of all phonetic algorithms (in part because it is a standard feature of popular database software such as [...] SQL.\n\nThe rules are as follows:\n\n1. Retain the first letter of the name and drop all other occurrences of a, e, i, o, u, y, h, w.\n2. Replace consonants with digits as follows (after the first letter):\n   - b, f, p, v → 1\n   - c, g, j, k, q, s, x, z → 2\n   - d, t → 3\n   - l → 4\n   - m, n → 5\n   - r → 6\n3. If two or more letters with the same number are adjacent in the original name (before step 1), only retain the first letter; also two letters with the same number separated by 'h' or 'w' are coded as a single number, whereas such letters separated by a vowel are coded twice. This rule also applies to the first letter.\n4. If you have too few letters in your word that you can't assign three numbers, append with zeros until there are three numbers. If you have four or more numbers, retain only the first three.",
      "type": "markdown"
    },
    {
      "id": "2598f1e1-a910-4212-b1ac-cdbfb1154489",
      "inputs": [
      ],
      "name": "soundex-definition",
      "source": "// Split the string\n@inline\ndef split_string[S] = n, substring[S,n,n]\n\tfrom n in range[1,num_chars[S],1]\n\n// Sound replacement rules\ndef soundex_replace =\n\t{ ({\"b\"; \"f\"; \"p\"; \"v\";}, \"1\");\n      ({\"c\"; \"g\"; \"j\"; \"k\"; \"q\"; \"s\"; \"x\"; \"z\";}, \"2\");\n      ({\"d\";\"t\";}, \"3\");\n      (\"l\", \"4\");\n      ({\"m\";\"n\";}, \"5\");\n      (\"r\", \"6\");\n      ({\"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\";}, \"0\"); }\n\n// Keep first letter\n@inline\ndef soundex_pre[S] = 0, uppercase[substring[S,1,1]]\n// Replace letters with sound encoding, drop letters without replacements\n@inline\ndef soundex_pre[S][n] = soundex_replace[ split_string[ lowercase[S]][n] ]\n\n// Remaining rules\n@inline\ndef soundex_filter[S](n,v) =\n\tsoundex_filter_1[S](n,v) and\n    not soundex_filter_1[S](n-1,v) and // No adjacent numbers the same\n\tnot v = \"0\" // No vowels\n\n@inline\ndef soundex_filter_1[S](n,v) = \n\tsoundex_sorted[S](n,v) and\n\tnot n = 2 and\n\tnot n = 3\n@inline\ndef soundex_filter_1[S](n,v) =\n\tsoundex_sorted[S](n-1,v) and\n\tnot soundex_sorted[S](n,v) and\n\tn = 3\n\n@inline\ndef soundex_sorted[S](m,vv) = sort[n,v: soundex_pre[S](n,v) ](m,nn,vv) from nn\n\n// Join string and pad with zeros\n@inline\ndef soundex[S] = substring[ concat[ string_join[\"\", soundex_filter[S]], \"000\"], 1, 4 ]",
      "type": "install"
    },
    {
      "id": "5c52351d-899f-4f2a-8fae-eee828c51240",
      "inputs": [
      ],
      "name": "",
      "source": "def test_strings = \n\t{ (\"Robert\", \"R163\");\n      (\"Rupert\", \"R163\");\n      (\"Rubin\", \"R150\");\n      (\"Ashcroft\", \"A261\");\n      (\"Ashcraft\", \"A261\");\n      (\"Tymczak\", \"T522\");\n      (\"Pfister\", \"P236\");\n      (\"Honeyman\", \"H555\"); }\n\n//def test_strings = {(\"Ashcraft\", \"A261\");}\n\ndef output = name, answer, result\n\tfrom name, answer, result where\n\ttest_strings(name, answer) and\n\tresult = soundex[name]",
      "type": "query"
    },
    {
      "id": "578da663-9a78-4d7f-abb5-c7fb5eff2a62",
      "inputs": [
      ],
      "name": "",
      "source": "def mystring = \"Pfister\"\n//def output = soundex[mystring] // T522\ndef output = soundex_filter_1[mystring]",
      "type": "query"
    },
    {
      "id": "015221f5-2e28-43b2-bf11-be478670c47e",
      "inputs": [
      ],
      "isCodeFolded": true,
      "name": "",
      "source": "## Rule variant\n\nAs implemented in most SQL languages, the algorithm is instead:\n\n1. Save the first letter. Map all occurrences of a, e, i, o, u, y, h, w. to zero(0)\n2. Replace all consonants (include the first letter) with digits as in [2.] above.\n3. Replace all adjacent same digits with one digit, and then remove all the zero (0) digits\n4. If the saved letter's digit is the same as the resulting first digit, remove the digit (keep the letter).\n5. Append 3 zeros if result contains less than 3 digits. Remove all except first letter and 3 digits after it (This step same as [4.] in explanation above).",
      "type": "markdown"
    }
  ],
  "metadata": {
    "notebookFormatVersion": "0.0.1"
  }
}