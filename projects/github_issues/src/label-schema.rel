/*****
 * Define schema for labels
 */

module repository

    def has_name[r] = json_repo[r,:name]
    def has_fullname[r] = json_repo[r,:full_name]

end


/*
module label

    // Attributes 
    
    // Belongs to repo
    def in_repo(lb,r) = regex_match(s, json_label[lb,:url]) and 
        repository:has_fullname(r,s)
        from s

    // Calculated properties
    
    def duration[:issue][:mean] = label_duration[mean][issue]
    def duration[:issue][:stddev] = label_duration[pop_stddev][issue]
    def duration[:pr][:mean] = label_duration[mean][pull_request]
    def duration[:pr][:stddev] = label_duration[pop_stddev][pull_request]
    // For issues that live 90 days or less?
    def duration[:quarter][:issue][:mean] = label_duration[mean][filter_by_duration[issue][90]]
    def duration[:quarter][:issue][:stddev] = label_duration[pop_stddev][filter_by_duration[issue][90]]
    def duration[:quarter][:pr][:mean] = label_duration[mean][filter_by_duration[pull_request][90]]
    def duration[:quarter][:pr][:stddev] = label_duration[pop_stddev][filter_by_duration[pull_request][90]]
    // Label occurance frequency
    //def frequency[lb] = count[gi: github_issue:has_label(gi,lb)]
    //def frequency[:quarter][lb] = count[gi: github_issue:has_label(gi,lb) and 
    //                                        filter_by_duration[GithubIssue][90](gi)]

end*/

def label:in_repo(lb,r) = regex_match(s, json_label[lb,:url]) and 
        repository:has_fullname(r,s)
        from s

// Label attributes 
def label:has[attr](lb,v) = json_label[lb,attr](v)
    and not { (:id);
              (:node_id); }(attr)


// Label categories 
def label:in[attr][lb] = has_label_category[cat][lb]
    from cat where
    category_relname(attr,cat)

def label:category_string[attr] = category_relname[attr]

// How long between when an issue is created and when it is closed?
// FILTER can take values issue, pull_request, GithubIssue
@inline
def label:duration[FILTER,AGG] = label_duration[FILTER,AGG]
// Doesn't work yet, use label_duration_period
@inline
def label:duration_period[FILTER,AGG][p] = label_duration_period[FILTER,AGG][p]

// How frequently does a label occur?
def label:count[lb] = count[gi: github_issue:has_label(gi,lb)]
// Doesn't work yet, use label_count_period
@inline
def label:count_period[p][lb] = label_count_period[p][lb]

/*** Parse label name ***/

// Get label categories, designated by a split character in the label name

def label_split_char = ':'

def regex_label_split_char = string_join[ "|", sort[string[label_split_char]] ]

// We want cat as a relname.
def has_label_category[cat][lb] = substring[label_string, ind+1, num_chars[label_string]]
    from label_string, ind, spl_char where
    cat = substring[label_string,1,ind-1] and
    label_string = json_label[lb,:name] and // Not using label:name due to error
    label_split_char(spl_char) and
    char(label_string,ind,spl_char) and
    not regex_match[regex_label_split_char, substring[label_string,1,ind-1]]

// This is a hack, hopefully relname_string will support conversion of any string to relname
def label_categories(cat) = has_label_category(cat,_,_)
def category_json_string = concat["{ \"", concat[s, "\": {} }"]] for s where label_categories(s)
def category_relname(c,s) = parse_json[ category_json_string[s] ](c)

/*** Label calculated properties ***/

/* Duration */

@inline
def label_duration[FILTER,AGG][lb] = 
    AGG[ gi, period: issue_duration(gi, period) and // github_issue:duration
                     github_issue:has_label(gi,lb) and // github_issue:has_label
                     FILTER(gi) and
                     Label(lb) ]

@inline
def label_duration_period[FILTER,AGG][p] = 
    label_duration[ filter_by_duration[FILTER][p] ][AGG]

/* Count (Frequency) */

@inline
def label_count_period[p][lb] =
    count[gi: github_issue:has_label(gi,lb) and 
              filter_by_duration[GithubIssue][p](gi)]